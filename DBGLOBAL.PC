/* dbglobal.pc */

#include "stdafx.h"

#include "ensqlcam.h"

#include "resource.h"
#include "alaptip.h"
#include "dbglobal.h"

#define SQLCA_STORAGE_CLASS extern
#undef  SQLCA_INIT

EXEC SQL INCLUDE sqlca ;

/* l. szez_all.sql n_nev_klcs_tmb_mer */
/* const unsigned NEV_TMB_MER   = 20 ; */
#define NEV_TMB_MER   20
/* l. szez_all.sql n_eredm_tmb_mer    */
/*const unsigned EREDM_TMB_MER = 50 ;*/
#define EREDM_TMB_MER 50

/* Az SQL_AltLekerd fuggvenyben hasznalt lekerdezeseket e sztringtombokbol allitom ossze */
/* A "SELECT n.rajtszam, n.versenyzo, n.nemzetiseg, n.csapat, n.motor" resz kozos        */
/* A lekerdezes tipusa szerint :                                                         */
char* gl_pLek1Tmb[]   = {                            /* , b.helyezes */
                          {", b.szezon_eve, b.nagydij_nev, b.ora, b.perc, b.masodperc, b.ezrdmsdp, b.megjegyzes " \
                           "FROM nevezesi_lista n, befuto b " \
                           "WHERE " \
                           "b.szezon_eve >= :n_szez_eve  AND " \
                           "n.kulcs      = b.nvzl_kulcs AND " \
                           "b.helyezes   = 1 AND "} , /* , r.helyezes */
                          {", r.szezon_eve, r.nagydij_nev, 0, r.perc, r.masodperc, r.ezrdmsdp, r.megjegyzes " \
                           "FROM nevezesi_lista n, rajtsorrend r " \
                           "WHERE " \
                           "r.szezon_eve >= :n_szez_eve AND " \
                           "n.kulcs      = r.nvzl_kulcs AND " \
                           "r.helyezes = 1 AND "} ,
                          {", l.szezon_eve, l.nagydij_nev, l.perc, l.masodperc, l.ezrdmsdp " \
                           "FROM nevezesi_lista n, leggyorsabb_kor l " \
                           "WHERE " \
                           "l.szezon_eve >= :n_szez_eve  AND " \
                           "n.kulcs      = l.nvzl_kulcs AND "}
                        } ;
/* Az utolsonal ^ kellhet meg : (l.korben, l.atl_sebesseg)  nem lesznek ugysem kijelezve */

char* gl_pLek2Tmb[]   = {
                          {" n.versenyzo   = :n_nev_kulcs "} ,
                          {" n.nemzetiseg  = :n_nev_kulcs "} ,
                          {" n.csapat      = :n_nev_kulcs "} ,
                          {" n.motor       = :n_nev_kulcs "} ,
                          {" b.nagydij_nev = :n_nev_kulcs "} ,
                          {" r.nagydij_nev = :n_nev_kulcs "} ,
                          {" l.nagydij_nev = :n_nev_kulcs "}
                        } ;

long SQL_COMMIT()
{
  long l_SQLCODE ;

  EXEC SQL COMMIT WORK ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  return l_SQLCODE ;
} ;

long SQL_ROLLBACK()
{
  long l_SQLCODE ;

  EXEC SQL ROLLBACK WORK ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  return l_SQLCODE ;
} ;

long SQL_FelvSzez( unsigned** ppSzezTomb, unsigned* pSzezdb)
{
  EXEC SQL BEGIN DECLARE SECTION ;

    unsigned flv_szez_tomb[FLV_SZEZ_BLK] ;

  EXEC SQL END DECLARE SECTION ;

  int       nElhozott ;
  unsigned* pIdglSzezTomb ;

  long l_SQLCODE ;

  EXEC SQL WHENEVER SQLERROR GOTO sql_hiba ;

  EXEC SQL PREPARE sel_flv_szez_ut
           FROM "SELECT szezon_eve FROM szezon" ;

  /* Ha nics hiba az utasitasokban, johet az erdemi resz */
  EXEC SQL DECLARE sel_flv_szez_krz CURSOR FOR sel_flv_szez_ut ;

  EXEC SQL OPEN sel_flv_szez_krz ;

  nElhozott = 0 ;
  *ppSzezTomb   = NULL ;
  pIdglSzezTomb = NULL ;

  EXEC SQL WHENEVER NOTFOUND do break ;

  while ( TRUE )
  {
    EXEC SQL FETCH sel_flv_szez_krz INTO :flv_szez_tomb ;

    if ( ( pIdglSzezTomb = new unsigned[sqlca.sqlerrd[2]] ) == NULL )
    {
      if ( nElhozott > 0 )
        delete *ppSzezTomb ;

      *ppSzezTomb = NULL ;
      *pSzezdb  = 0 ;

      SQL_SQLCAFeltolt() ;

      EXEC SQL CLOSE sel_flv_szez_krz ;

      EXEC SQL COMMIT WORK ;

      return -1 ;
    }

    memcpy( pIdglSzezTomb, *ppSzezTomb, nElhozott*sizeof( unsigned)) ;
    delete *ppSzezTomb ;
    *ppSzezTomb = pIdglSzezTomb ;
    memcpy( *ppSzezTomb+nElhozott, flv_szez_tomb, (sqlca.sqlerrd[2] - nElhozott)*sizeof( unsigned)) ;
    nElhozott = sqlca.sqlerrd[2] ;
  }

  if ( sqlca.sqlerrd[2] > nElhozott )
  {
    if ( ( pIdglSzezTomb = new unsigned[sqlca.sqlerrd[2]] ) == NULL )
    {
      if ( nElhozott > 0 )
        delete *ppSzezTomb ;

      *ppSzezTomb = NULL ;
      *pSzezdb  = 0 ;

      SQL_SQLCAFeltolt() ;

      EXEC SQL CLOSE sel_flv_szez_krz ;

      EXEC SQL COMMIT WORK ;

      return -1 ;
    }

    if ( nElhozott > 0 )
    {
      /* Csak, ha a while-ciklus mar lefutott egyszer */
      memcpy( pIdglSzezTomb, *ppSzezTomb, nElhozott*sizeof( unsigned)) ;
      delete *ppSzezTomb ;
    }

    *ppSzezTomb = pIdglSzezTomb ;
    memcpy( *ppSzezTomb+nElhozott, flv_szez_tomb, (sqlca.sqlerrd[2] - nElhozott)*sizeof( unsigned)) ;
    nElhozott = sqlca.sqlerrd[2] ;
  }

  *pSzezdb = nElhozott ;

  EXEC SQL WHENEVER NOTFOUND CONTINUE ;

  EXEC SQL CLOSE sel_flv_szez_krz ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL COMMIT WORK ;

  return l_SQLCODE ;

sql_hiba :

  EXEC SQL WHENEVER SQLERROR CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL CLOSE sel_flv_szez_krz ;

  return l_SQLCODE ;
}

long SQL_KulNvzlNdon( unsigned uiSzezEve, unsigned uiNagydKulcs,
                      unsigned** ppNvzlKulcsTomb, unsigned* pNvzldb)
{
  EXEC SQL BEGIN DECLARE SECTION ;

    unsigned n_szez_eve ;
    unsigned n_nd_kulcs ;

    /* a rajtsorrend tablaban nincsen ora mezo */
    struct sql_s_rsnvzl
    {
      unsigned n_nvz_kulcs  ;
    } rsnvzl_rekord[30] ;
    /* 30, hogy az esetek nagy reszeben egyszerre elhozzon mindent */
    /* Sok szezonban max 26 versenyzo allhatott rajthoz            */

  EXEC SQL END DECLARE SECTION ;

  int nFetch ;
  int nCiklFelsHat, nMeret ;

  unsigned* pIdglTbl   ;
  unsigned* pVisszaTbl ;

  long l_SQLCODE ;

  EXEC SQL WHENEVER SQLERROR GOTO sql_hiba ;
  EXEC SQL WHENEVER NOTFOUND do break ;

  pIdglTbl   = NULL ;
  pVisszaTbl = NULL ;

  n_szez_eve = uiSzezEve ;
  n_nd_kulcs = uiNagydKulcs ;

  /* Mely nevezesi lista bejegyzes fordult elo az adott szezon */
  /* adott nagydijan (Nem mint nevezesi lista bejegyzes )      */
  EXEC SQL PREPARE proba_utas FROM "SELECT nvzl_kulcs FROM rajtsorrend WHERE szezon_eve  = :n_szez_eve AND nagydij_nev = :n_nd_kulcs AND megjegyzes LIKE ('___________0____')" ;

  EXEC SQL DECLARE proba_kurz CURSOR FOR proba_utas ;

  EXEC SQL OPEN proba_kurz USING :n_szez_eve, :n_nd_kulcs ;

  nMeret = 0 ;
  nFetch = 0 ;

  while ( TRUE )
  {
    EXEC SQL FETCH proba_kurz INTO :rsnvzl_rekord ;

    /* Ez cikluson belul mindig 30 */
    nCiklFelsHat = sqlca.sqlerrd[2] - nFetch ;
    pIdglTbl = new unsigned[nMeret+nCiklFelsHat] ;

    if ( pIdglTbl == NULL )
    {
      delete [] pVisszaTbl ;

      return -1 ;
    }

    /* Atmasoljuk a regit az ideiglenes helyere */
    memcpy( pIdglTbl, pVisszaTbl, nMeret*sizeof(unsigned)) ;

    memcpy( pIdglTbl+nMeret, rsnvzl_rekord, nCiklFelsHat*sizeof(unsigned)) ;

    /* Toroljuk a regi tombot */
    delete [] pVisszaTbl ;
    pVisszaTbl = NULL ;

    nFetch = sqlca.sqlerrd[2] ;
    pVisszaTbl = pIdglTbl ;
    nMeret += nCiklFelsHat ;
  }

  nCiklFelsHat = sqlca.sqlerrd[2] - nFetch ;

  if ( nCiklFelsHat > 0 )
  {
    pIdglTbl = new unsigned[nMeret+nCiklFelsHat] ;

    if ( pIdglTbl == NULL )
    {
      delete [] pVisszaTbl ;

      return -1 ;
    }

    /* Atmasoljuk a regit az ideiglenes helyere */
    memcpy( pIdglTbl, pVisszaTbl, nMeret*sizeof(unsigned)) ;
    memcpy( pIdglTbl+nMeret, rsnvzl_rekord, nCiklFelsHat*sizeof(unsigned)) ;

    /* Toroljuk a regi tombot */
    delete [] pVisszaTbl ;
    pVisszaTbl = NULL ;

    pVisszaTbl = pIdglTbl ;
    nMeret += nCiklFelsHat ;
  }

  *pNvzldb = nMeret ;
  *ppNvzlKulcsTomb = pVisszaTbl ;

  EXEC SQL CLOSE proba_kurz ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL COMMIT WORK ;

  return l_SQLCODE ;

sql_hiba :

  EXEC SQL WHENEVER SQLERROR CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL CLOSE proba_kurz ;

  return l_SQLCODE ;
}

/*
ID_LEKERD_VERSENYZNV ID_LEKERD_NEMZETISGNV ID_LEKERD_CSAPAT ID_LEKERD_MOTORNV
ID_LEKERD_NAGYDJNV palya nevekre nincs lekerdezes

IDC_LEK1_FUTGY_RB2 IDC_LEK1_EDZELS_RB3 IDC_LEK1_LEGGYKOR_RB4 IDC_LEK1_OSSZER_RB5
*/
/* A visszaszallitott adatok tipusanak kulonbozosege miatt kell */
/* SQL_LgGyKorAltLekerd SQL_RajtsBefuto                      */
long SQL_LeggyKor( eLekerdTipus enLekTip, eNevtipus enNevTip,
                   unsigned nSzezEve, unsigned* pNevKlcsTmb, unsigned nBemTmbMeret,
                   sLgGyKorLekErTip** ppLgGyKorLekEr, unsigned* pKiTmbMeret)
{
  EXEC SQL BEGIN DECLARE SECTION ;

    unsigned n_szez_eve ;
    unsigned n_nev_klcs ;

    char     s_lekerd[400]  ;

    struct sql_s_lggyk_lek_tip
    {
      unsigned n_rajtszam    ;
      unsigned n_versenyzo   ;
      unsigned n_nemzetiseg  ;
      unsigned n_csapat      ;
      unsigned n_motor       ;
      unsigned n_szezon_eve  ;
      unsigned n_nagydij_nev ;
      unsigned n_perc        ;
      unsigned n_masodperc   ;
      unsigned n_ezrdmsdperc ;
/*      unsigned n_megjegyzes  ; itt ilyen nincs ! */
/*      unsigned n_korben      ;
      float    f_atl_sebesseg  nem lesz ugysem kijelezve */
    } lggyk_lek_rekord[EREDM_TMB_MER] ;

  EXEC SQL END DECLARE SECTION ;

  unsigned nAktNevElh   ;
  unsigned nCiklFelsHat ;
  unsigned nNevKlcsIdx  ;

  sLgGyKorLekErTip* pLokLgGyKorLekEr ;

  long l_SQLCODE ;

  EXEC SQL WHENEVER SQLERROR GOTO sql_hiba ;
  EXEC SQL WHENEVER NOTFOUND do break ;

  /* Ha nagyobb, mint nulla felszabaditom a hivo fv-bol a kimeneti tombot */
  *pKiTmbMeret = 0 ;
  *ppLgGyKorLekEr = NULL ;

  /* Az osszes eredmenyt egyel magasabb szinten kell osszerakni */
  /* SQL_RajtsBefuto es SQL_LgGyKorAltLekerd                 */
  if ( enLekTip != eLeggyKor )
  {
    return -1 ;
  }

/* TRACE("\nSQL_LgGyKorAltLekerd enNevTip:%d enLekTip:%d\n", enNevTip, enLekTip) ;*/

  switch ( enNevTip )
  {
    case eNagydijNt :
      sprintf( s_lekerd,
               "SELECT n.rajtszam, n.versenyzo, n.nemzetiseg, n.csapat, n.motor %s %s",
               gl_pLek1Tmb[enLekTip],
               gl_pLek2Tmb[enNevTip+enLekTip] ) ;
      break ;
    case eVersNt  :
    case eNemzNt  :
    case eCsapNt  :
    case eMotorNt :
      sprintf( s_lekerd,
               "SELECT n.rajtszam, n.versenyzo, n.nemzetiseg, n.csapat, n.motor %s %s",
               gl_pLek1Tmb[enLekTip],
               gl_pLek2Tmb[enNevTip] ) ;
      break ;

    default :
      /* Nemletezo nevtipus : hiba */
      return -1 ;
  }

/*TRACE("\nSQL_LgGyKorAltLekerd s_lekerd:%s\n", s_lekerd) ;*/

  /* 4. tip. din. SQL (ism.len szamu parameter) ?                    */
  /* rem maceras es a fuggvenybol valo visszaadas sem problamamentes */

  EXEC SQL PREPARE leggy_kor_ut FROM :s_lekerd ;

/*  n_bem_tmb_mer = nBemTmbMeret ; < ???*/

  EXEC SQL DECLARE leggy_kor_kurz CURSOR FOR leggy_kor_ut ;

  n_szez_eve = nSzezEve ;

  for ( nNevKlcsIdx = 0 ; nNevKlcsIdx < nBemTmbMeret ; nNevKlcsIdx++ )
  {
    n_nev_klcs = pNevKlcsTmb[nNevKlcsIdx] ;

    /* Mivel minden kurzornyitasnal(nevnel) sqlca.sqlerrd[2] nullarol kezdodik */
    nAktNevElh = 0 ;

    EXEC SQL OPEN leggy_kor_kurz USING :n_szez_eve, :n_nev_klcs ;

    EXEC SQL WHENEVER NOTFOUND do break ;/* Es ha a for-bol is kiugrik ? */

    while ( TRUE )
    {
      EXEC SQL FETCH leggy_kor_kurz INTO :lggyk_lek_rekord ;

      pLokLgGyKorLekEr = new sLgGyKorLekErTip[*pKiTmbMeret+sqlca.sqlerrd[2]] ;

      if ( pLokLgGyKorLekEr == NULL )
      {
        EXEC SQL CLOSE leggy_kor_kurz ;

        *pKiTmbMeret = *pKiTmbMeret + nAktNevElh ;

        return -1 ;
      }

      /* Atmasoljuk a regit az ideiglenes helyere */
      memcpy( pLokLgGyKorLekEr, *ppLgGyKorLekEr, (*pKiTmbMeret+nAktNevElh)*sizeof(sLgGyKorLekErTip)) ;

      /* Hozzamasoljuk az ujonnan elhozottakat    */
      memcpy( pLokLgGyKorLekEr+*pKiTmbMeret+nAktNevElh, lggyk_lek_rekord, EREDM_TMB_MER*sizeof(sLgGyKorLekErTip)) ;

      /* Toroljuk a regi tombot */
      delete [] *ppLgGyKorLekEr ;

      *ppLgGyKorLekEr = pLokLgGyKorLekEr ;

      nAktNevElh = sqlca.sqlerrd[2] ;
    }

    nCiklFelsHat = sqlca.sqlerrd[2] - nAktNevElh ;
    if ( nCiklFelsHat > 0 )
    {
      pLokLgGyKorLekEr = new sLgGyKorLekErTip[*pKiTmbMeret+sqlca.sqlerrd[2]] ;

      /* A mar elhozottakat nem szabaditjuk fel, *pKiTmbMeret mindig aktualis */
      if ( pLokLgGyKorLekEr == NULL )
      {
        EXEC SQL CLOSE leggy_kor_kurz ;

        *pKiTmbMeret = *pKiTmbMeret + nAktNevElh ;

        return -1 ;
      }

      /* Atmasoljuk a regit az ideiglenes helyere */
      memcpy( pLokLgGyKorLekEr, *ppLgGyKorLekEr, (*pKiTmbMeret+nAktNevElh)*sizeof(sLgGyKorLekErTip)) ;

      /* Hozzamasoljuk az ujonnan elhozottakat    */
      memcpy( pLokLgGyKorLekEr+*pKiTmbMeret+nAktNevElh, lggyk_lek_rekord, nCiklFelsHat*sizeof(sLgGyKorLekErTip)) ;

      /* Toroljuk a regi tombot */
      delete [] *ppLgGyKorLekEr ;

      *ppLgGyKorLekEr = pLokLgGyKorLekEr ;

      nAktNevElh = sqlca.sqlerrd[2] ;
    }

    *pKiTmbMeret = *pKiTmbMeret + nAktNevElh ;

    EXEC SQL CLOSE leggy_kor_kurz ;
  }

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL COMMIT WORK ;

  return l_SQLCODE ;

sql_hiba :

  EXEC SQL WHENEVER SQLERROR CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL CLOSE leggy_kor_kurz ;

  return l_SQLCODE ;
} ;

long SQL_RajtsBefuto( eLekerdTipus enLekTip, eNevtipus enNevTip,
                      unsigned nSzezEve, unsigned* pNevKlcsTmb, unsigned nBemTmbMeret,
                      sRsBefLekErTip** ppRsBefLekEr, unsigned* pKiTmbMeret)
{
  EXEC SQL BEGIN DECLARE SECTION ;

/*    unsigned n_bem_tmb_mer ;*/

    unsigned n_szez_eve ;
    unsigned n_nev_klcs ;
    char      s_lekerd[400]  ;

    struct sql_s_rs_bef_lek_tip
    {
      unsigned n_rajtszam    ;
      unsigned n_versenyzo   ;
      unsigned n_nemzetiseg  ;
      unsigned n_csapat      ;
      unsigned n_motor       ;
      unsigned n_szezon_eve  ;
      unsigned n_nagydij_nev ;
/*      unsigned n_helyezes    ;*/
      unsigned n_ora         ;
      unsigned n_perc        ;
      unsigned n_masodperc   ;
      unsigned n_ezrdmsdperc ;
      unsigned n_megjegyzes  ;
    } rs_bef_lek_rekord[EREDM_TMB_MER] ;

  EXEC SQL END DECLARE SECTION ;

  unsigned nAktNevElh   ;
  unsigned nNevKlcsIdx  ;

  sRsBefLekErTip* pLokRsBefLekEr ;

  long l_SQLCODE ;

  EXEC SQL WHENEVER SQLERROR GOTO sql_hiba ;
  EXEC SQL WHENEVER NOTFOUND do break ;

  *pKiTmbMeret = 0 ;
  *ppRsBefLekEr = NULL ;

  /* Az osszes eredmenyt egyel magasabb szinten kell osszerakni */
  /* SQL_RajtsBefuto es SQL_LgGyKorAltLekerd                 */
  if ( enLekTip != eFutgy && enLekTip != eEdzEls )
  {
    return -1 ;
  }

/*TRACE("\nSQL_RajtsBefuto enNevTip:%d enLekTip:%d\n", enNevTip, enLekTip) ;*/

  switch ( enNevTip )
  {
    case eNagydijNt :
      sprintf( s_lekerd,
               "SELECT n.rajtszam, n.versenyzo, n.nemzetiseg, n.csapat, n.motor%s %s",
               gl_pLek1Tmb[enLekTip],
               gl_pLek2Tmb[enNevTip+enLekTip] ) ;
      break ;
    case eVersNt  :
    case eNemzNt  :
    case eCsapNt  :
    case eMotorNt :
      sprintf( s_lekerd,
               "SELECT n.rajtszam, n.versenyzo, n.nemzetiseg, n.csapat, n.motor%s %s",
               gl_pLek1Tmb[enLekTip],
               gl_pLek2Tmb[enNevTip] ) ;
      break ;

    default :
      /* Nemletezo nevtipus : hiba */
      return -1 ;
  }

/*TRACE("\ns_lekerd:%s\n", s_lekerd) ;*/

  EXEC SQL PREPARE alt_lek_ut FROM :s_lekerd ;

  EXEC SQL DECLARE alt_lek_kurz2 CURSOR FOR alt_lek_ut ;

  n_szez_eve = nSzezEve ;

  for ( nNevKlcsIdx = 0 ; nNevKlcsIdx < nBemTmbMeret ; nNevKlcsIdx++ )
  {
    n_nev_klcs = pNevKlcsTmb[nNevKlcsIdx] ;

    nAktNevElh = 0 ;

    EXEC SQL OPEN alt_lek_kurz2 USING :n_szez_eve, :n_nev_klcs ;

    EXEC SQL WHENEVER NOTFOUND do break ;

    while ( TRUE )
    {
      EXEC SQL FETCH alt_lek_kurz2 INTO :rs_bef_lek_rekord ;
/*>>>*/
      pLokRsBefLekEr = new sRsBefLekErTip[*pKiTmbMeret+sqlca.sqlerrd[2]] ;

      if ( pLokRsBefLekEr == NULL )
      {
        EXEC SQL CLOSE alt_lek_kurz2 ;
        return -1 ;
      }

      /* Atmasoljuk a regit az ideiglenes helyere */
      memcpy( pLokRsBefLekEr, *ppRsBefLekEr, (*pKiTmbMeret+nAktNevElh)*sizeof(sRsBefLekErTip)) ;

      /* Hozzamasoljuk az ujonnan elhozottakat. Itt a meret mindig EREDM_TMB_MER */
      memcpy( pLokRsBefLekEr+*pKiTmbMeret+nAktNevElh, rs_bef_lek_rekord, EREDM_TMB_MER*sizeof(sRsBefLekErTip)) ;

      /* Toroljuk a regi tombot */
      delete [] *ppRsBefLekEr ;

      *ppRsBefLekEr = pLokRsBefLekEr ;

      nAktNevElh = sqlca.sqlerrd[2] ;
    }

/*>>>*/
    if ( sqlca.sqlerrd[2] - nAktNevElh > 0 )
    {
      pLokRsBefLekEr = new sRsBefLekErTip[*pKiTmbMeret+sqlca.sqlerrd[2]] ;

      /* A mar elhozottakat nem szabaditjuk fel, *pKiTmbMeret mindig aktualis */
      if ( pLokRsBefLekEr == NULL )
      {
        EXEC SQL CLOSE alt_lek_kurz2 ;
        return -1 ;
      }

      /* Atmasoljuk a regit az ideiglenes helyere */
      memcpy( pLokRsBefLekEr, *ppRsBefLekEr, (*pKiTmbMeret+nAktNevElh)*sizeof(sRsBefLekErTip)) ;

      /* Hozzamasoljuk az ujonnan elhozottakat    */
      memcpy( pLokRsBefLekEr+*pKiTmbMeret+nAktNevElh,
              rs_bef_lek_rekord,
              (sqlca.sqlerrd[2] - nAktNevElh)*sizeof(sRsBefLekErTip)) ;

      /* Toroljuk a regi tombot */
      delete [] *ppRsBefLekEr ;

      *ppRsBefLekEr = pLokRsBefLekEr ;

      nAktNevElh = sqlca.sqlerrd[2] ;
    }

    EXEC SQL CLOSE alt_lek_kurz2 ;

    *pKiTmbMeret = *pKiTmbMeret + nAktNevElh ;
  }

  EXEC SQL WHENEVER NOTFOUND CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL COMMIT WORK ;

  return l_SQLCODE ;

sql_hiba :

  EXEC SQL WHENEVER SQLERROR CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL CLOSE alt_lek_kurz2 ;

  return l_SQLCODE ;
} ;

#define HOST_TMB_MER 50

long SQL_HolVersKiVers( eNevtipus enNevTip,
                        unsigned nSzezEve, unsigned* pNevKlcsTmb, unsigned nBemTmbMeret,
                        sHolVKiVLekErTip** ppHolVKiVLekEr, unsigned* pKiTmbMeret)
{
  EXEC SQL BEGIN DECLARE SECTION ;

    unsigned  n_szez_tol ;

    unsigned  n_nev_klcs ;

    char      s_nvzl_lekerd[300] ;

    /* A nevezesi kulcs kiveve a nvzl_klcs_tmb-bol, */
    /* mert masik kurzor   bemenoadata              */
    unsigned  nvzl_klcs_tmb[HOST_TMB_MER] ;
    
    /* Az eppen elhozott nevezesi lista elemek szamat adja meg a */
    /* kovetkezo kurzor megnyitasakor                            */
    unsigned n_elhozott_nvzl ;

    struct sql_s_nvzl_tip
    {
      unsigned n_versenyzo  ;
      unsigned n_nemzetiseg ;
      unsigned n_csapat     ;
      unsigned n_motor      ;
    } nvzl_tmb[HOST_TMB_MER] ;

    /* A nevezesi lista adatok nem elegendoek kell a nagydij es datum is */
    /* Ezeket kulon lekerdezessel hozom el                               */
    struct sql_s_nagyd_tip
    {
/*      unsigned n_nvzl_kulcs  ; ezt nem tudom a lekerdezessel elhozni */
      unsigned n_nagydij_nev ;
/*      unsigned n_palya_nev   ;*/
      char     c_datum[13]   ;
    } nagyd_rekord[HOST_TMB_MER] ;

  EXEC SQL END DECLARE SECTION ;

  sHolVKiVLekErTip* pLokHolVKiVLekEr ;

  unsigned nNvzlIdx     ;
  unsigned nOsszElhNvzl ;
  unsigned nNagydIdx    ;
  unsigned nOsszElhNd   ;
  unsigned nAktElhNd    ;
  unsigned nKiTmbFogl   ;
  unsigned nNevKlcsIdx  ;

  long l_SQLCODE ;

  EXEC SQL WHENEVER SQLERROR GOTO sql_hiba ;
  EXEC SQL WHENEVER NOTFOUND CONTINUE ;

  nOsszElhNvzl    = 0 ;
  n_elhozott_nvzl = 0 ;
  nKiTmbFogl      = 0 ;
  pLokHolVKiVLekEr= NULL ; 
  *pKiTmbMeret    = 0 ;
  *ppHolVKiVLekEr = NULL ;

/*TRACE("\nSQL_HolVersKiVers enNevTip:%d\n", enNevTip) ;*/

  switch ( enNevTip )
  {
    case eVersNt  :
    case eNemzNt  :
    case eCsapNt  :
    case eMotorNt :
       sprintf( s_nvzl_lekerd,
               "SELECT kulcs, versenyzo, nemzetiseg, csapat, motor\n" \
               "FROM nevezesi_lista n\n" \
               "WHERE %s",
               gl_pLek2Tmb[enNevTip] ) ;
      break ;

    default :
      /* Hibas nevtipus */
      return -1 ;
  }

/*TRACE("\nSQL_HolVersKiVers s_nvzl_lekerd:%s\n", s_nvzl_lekerd) ;*/

  /* A nev kulcsokbol nevezesi lista adatokat  eloallito */
  /* lekerdezes elokeszitese                             */
  EXEC SQL PREPARE nvzl_lekerd_ut FROM :s_nvzl_lekerd ;

  EXEC SQL DECLARE nvzl_lekerd_kurz CURSOR FOR nvzl_lekerd_ut ;

  /* A nevezesi lista kulcsokbol nagydij/palya neveket   */
  /* datumokat aloallito lekerdezes elokeszitese         */
  EXEC SQL PREPARE nagyd_lekerd_ut FROM
    "SELECT nagydij_nev, TO_CHAR(datum,'YYYY-MM-DD') FROM nagydijak WHERE datum IN (SELECT MIN(nd.datum) FROM rajtsorrend r, nevezesi_lista n, nagydijak nd WHERE r.nvzl_kulcs = :a AND r.szezon_eve >= :b AND nd.szezon_eve = r.szezon_eve AND nd.nagydij_nev=r.nagydij_nev AND n.kulcs=r.nvzl_kulcs GROUP BY(r.szezon_eve))" ;
  /*, palya_nev*/

  EXEC SQL DECLARE nagyd_lekerd_kurz CURSOR FOR nagyd_lekerd_ut ;

  n_szez_tol = nSzezEve ;

  for ( nNevKlcsIdx = 0 ; nNevKlcsIdx < nBemTmbMeret ; nNevKlcsIdx++ )
  {
    n_nev_klcs = pNevKlcsTmb[nNevKlcsIdx] ;

    EXEC SQL OPEN nvzl_lekerd_kurz USING :n_nev_klcs ;

    while ( TRUE )
    {
      EXEC SQL FETCH nvzl_lekerd_kurz INTO :nvzl_klcs_tmb, :nvzl_tmb ;

      /* n_elhozott_nvzl altalaban megegyezik HOST_TMB_MER-rel, kiveve az      */
      /* utolso menetet, ekkor fontos, hogy csak a tenyleges szammal dolgozzon */
/*TRACE("\nn_nev_klcs(%d) -> %d darab nvzl klcs-ot talalt\n", n_nev_klcs, sqlca.sqlerrd[2]) ;*/
      n_elhozott_nvzl = sqlca.sqlerrd[2] - nOsszElhNvzl ; /* ??? a masodik nevnel 0 az eredmeny ! */

      /* Az ujonnan elhozott nagydij eredmenyek osszefesulese a nevezesi lista adatokkal */
      for ( nNvzlIdx = 0 ; nNvzlIdx < n_elhozott_nvzl ; nNvzlIdx++ )
      {
        /* A nevezesi lista kulcsonkent nyitom meg a kurzort,mert nem tudom      */
        /* elhozni a nevezesi lista kulcsot a lekerdezesbol                      */

/*TRACE("\nnvzl_klcs_tmb[%d]:%d , n_szez_tol:%d\n", nNvzlIdx, nvzl_klcs_tmb[nNvzlIdx], n_szez_tol) ;*/

        EXEC SQL OPEN nagyd_lekerd_kurz USING :nvzl_klcs_tmb[nNvzlIdx], :n_szez_tol ;

/*      nOsszElhNd = 0 ;*/

        EXEC SQL FETCH nagyd_lekerd_kurz INTO :nagyd_rekord ;

        nAktElhNd = sqlca.sqlerrd[2] /*- 0 (nOsszElhNd)*/ ;

        /* Csak, ha hozott el uj elso nagydij adatot, lehet veluk tovabb dolgozni */
        while ( nAktElhNd > 0 )
        {
          /* Ha a tenylegesen elhozott adatok (*pKiTmbMeret) + a potencialisak(nAktElhNd) */
          /* nem fernek be a lefoglalt teruletre (nKiTmbFogl)                             */
          if ( *pKiTmbMeret + nAktElhNd > nKiTmbFogl )
          {
            pLokHolVKiVLekEr = new sHolVKiVLekErTip[nKiTmbFogl+nAktElhNd] ;

            if ( pLokHolVKiVLekEr == NULL )
            {
              /* A kurzorok lezarasa */
              EXEC SQL CLOSE nagyd_lekerd_kurz ;
              EXEC SQL CLOSE nvzl_lekerd_kurz  ;

              return -1 ;
            }

            nKiTmbFogl = nKiTmbFogl + nAktElhNd ;

            /* Az eddig beirtak atmasolasa */
            memcpy( pLokHolVKiVLekEr, *ppHolVKiVLekEr, (*pKiTmbMeret)*sizeof(sHolVKiVLekErTip)) ;
          }

          /* Egy nNvzlIdx-hez tobb nNagydIdx is jo lehet ! Ezert megy mindig vegig. */
          for ( nNagydIdx = 0 ; nNagydIdx < nAktElhNd ; nNagydIdx++ )
          {
            /* Ideiglenesen hasznaljuk a 'celtombot', az index csak akkor megy tovabb, */
            /* ha a bejegyzes kesobbi, mint a datumfeltetel */
            sscanf( nagyd_rekord[nNagydIdx].c_datum,/*<- "11-MAR-90"*/
                    "%d-%d-%d",
                    &(pLokHolVKiVLekEr+*pKiTmbMeret)->uiEv,
                    &(pLokHolVKiVLekEr+*pKiTmbMeret)->uiHonap,
                    &(pLokHolVKiVLekEr+*pKiTmbMeret)->uiNap) ;

            (pLokHolVKiVLekEr+*pKiTmbMeret)->uiVersenyzo  = nvzl_tmb[nNvzlIdx].n_versenyzo  ;
            (pLokHolVKiVLekEr+*pKiTmbMeret)->uiNemzetiseg = nvzl_tmb[nNvzlIdx].n_nemzetiseg ;
            (pLokHolVKiVLekEr+*pKiTmbMeret)->uiCsapat     = nvzl_tmb[nNvzlIdx].n_csapat     ;
            (pLokHolVKiVLekEr+*pKiTmbMeret)->uiMotor      = nvzl_tmb[nNvzlIdx].n_motor      ;
            (pLokHolVKiVLekEr+*pKiTmbMeret)->uiNagydijNev = nagyd_rekord[nNagydIdx].n_nagydij_nev ;

/*
TRACE("\nV:%d, N:%d, C:%d, M:%d, E:%d, H:%d, N:%d",
       nvzl_tmb[nNvzlIdx].n_versenyzo,
       nvzl_tmb[nNvzlIdx].n_nemzetiseg,
       nvzl_tmb[nNvzlIdx].n_csapat,
       nvzl_tmb[nNvzlIdx].n_motor,
       (pLokHolVKiVLekEr+*pKiTmbMeret)->uiEv,
       (pLokHolVKiVLekEr+*pKiTmbMeret)->uiHonap,
       (pLokHolVKiVLekEr+*pKiTmbMeret)->uiNap
     ) ;
*/

            (*pKiTmbMeret)++ ;
          }

          /* Tulajdonkeppen itt veszi eszre, hogy elfogytak az adatok */
          /* break helyett a ciklusvaltozot allitja                   */
          if ( nAktElhNd == HOST_TMB_MER )
          {
            nOsszElhNd = sqlca.sqlerrd[2] ;

            EXEC SQL FETCH nagyd_lekerd_kurz INTO :nagyd_rekord ;

            nAktElhNd = sqlca.sqlerrd[2] - nOsszElhNd ;
          }
          else
          {
            nAktElhNd = 0 ;
          }
        }

        delete [] *ppHolVKiVLekEr ;
        *ppHolVKiVLekEr = pLokHolVKiVLekEr ;
/*      nNagydLekMer = nNagydLekMer + nAktElhNd ;*/

        EXEC SQL CLOSE nagyd_lekerd_kurz ;
/*      break ;*/
      }

      nOsszElhNvzl = nOsszElhNvzl + n_elhozott_nvzl ;

      /* Ha eppen az utolso - nem teljes tombmeretu adagot dolgozta fel */
      if ( n_elhozott_nvzl < HOST_TMB_MER )
      {
        EXEC SQL CLOSE nvzl_lekerd_kurz ;
        break ;
      }
    }

    /* A ket OPEN kozti lezaras az ANSI kompatibilitas miatt kell */
    EXEC SQL CLOSE nvzl_lekerd_kurz ;

    /* Uj kurzor eseten megint 0-rol kell kezdeni,kulonben n_elhozott_nvzl negativ is lehet */
    nOsszElhNvzl = 0 ;
  } /* for a bejovo nevkulcsok tombjen */

/*  delete [] pLokHolVKiVLekEr ;*/

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL CLOSE nagyd_lekerd_kurz ;
  EXEC SQL CLOSE nvzl_lekerd_kurz  ;

  return l_SQLCODE ;

sql_hiba :

  /* A feltetelt tartalmazo valtozotombok felszabaditasa */
/*  delete [] pLokHolVKiVLekEr ; ??? */

  EXEC SQL WHENEVER SQLERROR CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  EXEC SQL CLOSE nagyd_lekerd_kurz ;
  EXEC SQL CLOSE nvzl_lekerd_kurz  ;

  return l_SQLCODE ;
} ;

/* , unsigned* pKiTmbMeret nem hasznalatos. Helyette : sPillAllLekEr.uiOsszErTmbMer */
long SQL_PillAll( unsigned          nSzezon,       eNevtipus enNevTip,
                  unsigned*         pNevKlcsTmb,   unsigned  nNevTmbMeret,
                  sPillAllLekErTip* pPillAllLekEr)
{
  EXEC SQL BEGIN DECLARE SECTION ;

    /* A tarolt eljarasok bemeno adatai */
    unsigned n_szez_eve ;
    unsigned n_nevtipus ;

    unsigned nev_klcs_tmb[NEV_TMB_MER] ;
    unsigned n_nev_klcs_tmb_mer ;

    /* A tarolt eljarasok kimeno adatai */
    unsigned nev_hlyz_tmb[NEV_TMB_MER] ;
    unsigned szez_pnt_tmb[NEV_TMB_MER] ;

    /* Az osszes beszamitott eredmeny szama */
    unsigned n_ossz_er_tmb_mer ;

    /* Az eppen elhozott beszamitott eredmenyek szama */
    unsigned n_ki_besz_tab_mer ;

    /* Az osszes eredmeny mezoit tartalmazo tombok */
    unsigned nev_eredm_tmb[EREDM_TMB_MER] ;
    unsigned pont_tab[EREDM_TMB_MER]      ;
    unsigned helyezes_tab[EREDM_TMB_MER]  ;
    unsigned nvzl_kulcs_tab[EREDM_TMB_MER];
    unsigned nd_nev_tab[EREDM_TMB_MER]    ;

  EXEC SQL END DECLARE SECTION ;

  unsigned nElhSzama ;
  unsigned i ;
  unsigned nElhIdx   ;

  unsigned nHosszRegi, nHosszUj;

  unsigned nBeszEredmMer   ;
  unsigned nUtElhNevIdx    ;

  /* A futam eredmenyek elhozatalanal csak a szezonban */
  /* eredmenyt elert neveket itt tarolom               */
  unsigned  nLokNevTmbMeret ;
  unsigned* pLokNevKlcsTmb ;

  unsigned* pINevEredmTmb  ;
  unsigned* pIPontTmb      ;
  unsigned* pIHelyezesTmb  ;
  unsigned* pINvzlKulcsTmb ;
  unsigned* pINdNevTmb     ;

  unsigned* pIdNevKlcsTmb ;
  unsigned* pIdNevHlyzTmb ;
  unsigned* pIdSzezPntTmb ;

  unsigned  nIdIdx, nIdx1, nIdx2 ;

  BOOL bMindElhoz ;

  long l_SQLCODE ;

  EXEC SQL WHENEVER SQLERROR GOTO sql_hiba ;
  EXEC SQL WHENEVER NOTFOUND CONTINUE ;

  n_szez_eve = nSzezon  ;
  n_nevtipus = enNevTip ;

  if ( enNevTip == eNemzNt || enNevTip == eCsapNt || enNevTip == eMotorNt )
  {
    EXEC SQL EXECUTE
      BEGIN

        /* a nevek (csapat/versenyzo) szerinti eredmenyeket osszeallito szkript felhivasa */
        szez_all.szez_pill_all_cs( :n_szez_eve, :n_nevtipus) ;

      END ;
    END-EXEC ;
  }
  else
  {
    EXEC SQL EXECUTE
      BEGIN

        /* a nevek (csapat/versenyzo) szerinti eredmenyeket osszeallito szkript felhivasa */
        szez_all.szez_pill_all_v( :n_szez_eve) ;

      END ;
    END-EXEC ;
  }

  /* ----------------------------------------------------------------------- */

  /* Vannak megadva elhozando nevek ? */
  if ( nNevTmbMeret > 0 )
  {
    bMindElhoz = FALSE ;

    /* Hany menetben tudjuk NEV_TMB_MER adagokban elhozni az eredmenyt ? */
    nElhSzama = nNevTmbMeret / NEV_TMB_MER + 1 ;
    nElhIdx = 0 ;

    for ( i = 0 ; i < nElhSzama ; i++ )
    {
      /* Nem mindig teljes meretu tombot kell mozgatni */
      if ( nNevTmbMeret > NEV_TMB_MER + nElhIdx)
      {
        n_nev_klcs_tmb_mer =  NEV_TMB_MER ;
      }
      else
      {
        n_nev_klcs_tmb_mer = nNevTmbMeret - nElhIdx ;
      }

      memcpy( nev_klcs_tmb, pNevKlcsTmb + nElhIdx, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
/*
for ( unsigned b = 0 ; b < n_nev_klcs_tmb_mer ; b++ )
{
  TRACE("\nnev_klcs_tmb[%d]:%d", b, nev_klcs_tmb[b]) ;
}
*/
      EXEC SQL EXECUTE
        BEGIN

          /* Az adott nevek hanyadikak lettek, hany ponttal */
          szez_all.szez_eredm_elhoz( :nev_klcs_tmb, :n_nev_klcs_tmb_mer, :nev_hlyz_tmb, :szez_pnt_tmb) ;

        END ;
      END-EXEC ;
/*
for ( unsigned a = 0 ; a < n_nev_klcs_tmb_mer ; a++ )
{
  TRACE("\na:%d nev_klcs_tmb:%d nev_hlyz_tmb:%d szez_pnt_tmb:%d", a, nev_klcs_tmb[a], nev_hlyz_tmb[a], szez_pnt_tmb[a]) ;
}
*/
      /* Helyfoglalas a kimenoadatoknak: Nem feltetlen ert el minden nev eredmenyt */
      /* A kivalasztottak kozul ezek ertek el eredmenyt */
      pIdNevKlcsTmb = new unsigned [pPillAllLekEr->uiSzezErTmbMeret+n_nev_klcs_tmb_mer] ;
      if ( pIdNevKlcsTmb == NULL )
      {
        return -1 ;
      }

      /* A szezon vegen elert helyezes  */
      pIdNevHlyzTmb = new unsigned [pPillAllLekEr->uiSzezErTmbMeret+n_nev_klcs_tmb_mer] ;
      if ( pIdNevHlyzTmb == NULL )
      {
        delete [] pIdNevKlcsTmb ;
        return -1 ;
      }

      /* A figyelembe vett pontok a szezon vegen */
      pIdSzezPntTmb = new unsigned [pPillAllLekEr->uiSzezErTmbMeret+n_nev_klcs_tmb_mer] ;
      if ( pIdSzezPntTmb == NULL )
      {
        delete [] pIdNevKlcsTmb ;
        delete [] pIdNevHlyzTmb ;
        return -1 ;
      }

      if ( i == 0 )
      {
        memcpy( pIdNevKlcsTmb, nev_klcs_tmb, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
        memcpy( pIdNevHlyzTmb, nev_hlyz_tmb, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
        memcpy( pIdSzezPntTmb, szez_pnt_tmb, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
      }
      else
      {
        nIdIdx = nIdx1 = nIdx2 = 0 ;

        while ( TRUE )
        {
          if ( nIdx1 < pPillAllLekEr->uiSzezErTmbMeret )
          {
            if ( nIdx2 < n_nev_klcs_tmb_mer )
            {
              /* Mindkettobol van meg */
              if ( pPillAllLekEr->pNevHlyzTmb[nIdx1] < nev_hlyz_tmb[nIdx2] )
              {
                pIdNevKlcsTmb[nIdIdx] = pPillAllLekEr->pNevKlcsTmb[nIdx1] ;
                pIdNevHlyzTmb[nIdIdx] = pPillAllLekEr->pNevHlyzTmb[nIdx1] ;
                pIdSzezPntTmb[nIdIdx] = pPillAllLekEr->pSzezPntTmb[nIdx1] ;

                nIdx1++ ;
              }
              else
              {
                pIdNevKlcsTmb[nIdIdx] = nev_klcs_tmb[nIdx2] ;
                pIdNevHlyzTmb[nIdIdx] = nev_hlyz_tmb[nIdx2] ;
                pIdSzezPntTmb[nIdIdx] = szez_pnt_tmb[nIdx2] ;

                nIdx2++ ;
              }
            }
            else
            {
              /* nev_hlyz_tmb elfogyott */
              pIdNevKlcsTmb[nIdIdx] = pPillAllLekEr->pNevKlcsTmb[nIdx1] ;
              pIdNevHlyzTmb[nIdIdx] = pPillAllLekEr->pNevHlyzTmb[nIdx1] ;
              pIdSzezPntTmb[nIdIdx] = pPillAllLekEr->pSzezPntTmb[nIdx1] ;

              nIdx1++ ;
            }
          }
          else
          {
            /* pPillAllLekEr->pNevHlyzTmb elfogyott */
            if ( nIdx2 < n_nev_klcs_tmb_mer )
            {
              pIdNevKlcsTmb[nIdIdx] = nev_klcs_tmb[nIdx2] ;
              pIdNevHlyzTmb[nIdIdx] = nev_hlyz_tmb[nIdx2] ;
              pIdSzezPntTmb[nIdIdx] = szez_pnt_tmb[nIdx2] ;

              nIdx2++ ;
            }
            else
            {
              /* Mindketto elfogyott -> KESZ, VEGE */
              break ;
            }
          }

          nIdIdx++ ;
        }
      }

      delete [] pPillAllLekEr->pNevKlcsTmb ;
      delete [] pPillAllLekEr->pNevHlyzTmb ;
      delete [] pPillAllLekEr->pSzezPntTmb ;

      pPillAllLekEr->pNevKlcsTmb = pIdNevKlcsTmb ;
      pPillAllLekEr->pNevHlyzTmb = pIdNevHlyzTmb ;
      pPillAllLekEr->pSzezPntTmb = pIdSzezPntTmb ;

      nElhIdx += NEV_TMB_MER ;
      pPillAllLekEr->uiSzezErTmbMeret += n_nev_klcs_tmb_mer ;
    }

/*
for ( unsigned ui = 0 ; ui < 18 ; ui++ )
{
  TRACE("\nui:%d nev_klcs_tmb:%d nev_hlyz_tmb:%d szez_pnt_tmb:%d",
        ui,
        pPillAllLekEr->pNevKlcsTmb[ui],
        pPillAllLekEr->pNevHlyzTmb[ui],
        pPillAllLekEr->pSzezPntTmb[ui]) ;
}
*/
  }
  else /* Minden eredmenyt elert nevet el kell hozni */
  {
    /* A feltetelul szolgalo valtozo elallitodik, es kesobb kell */
    bMindElhoz = TRUE ;

    /* Az adott szezonban eredmenyt elert nevek szama                  */
    /* Nem csak a feluleten kivalasztottake:minden nevet el kell hozni */
    EXEC SQL EXECUTE
      BEGIN

        :n_nev_klcs_tmb_mer := szez_all.n_max_szez_idx ;

      END ;
    END-EXEC ;

    if ( n_nev_klcs_tmb_mer > 0 )
    {
      pPillAllLekEr->uiSzezErTmbMeret = n_nev_klcs_tmb_mer ;

      /* Helyfoglalas a kimenoadatoknak */
      pPillAllLekEr->pNevKlcsTmb  = new unsigned [n_nev_klcs_tmb_mer] ;
      if ( pPillAllLekEr->pNevKlcsTmb  == NULL )
      {
        return -1 ;
      }

      /* A szezon vegen elert helyezes  */
      pPillAllLekEr->pNevHlyzTmb = new unsigned [n_nev_klcs_tmb_mer] ;
      if ( pPillAllLekEr->pNevHlyzTmb == NULL )
      {
        delete [] pPillAllLekEr->pNevKlcsTmb  ;
        return -1 ;
      }

      /* A figyelembe vett pontok a szezon vegen */
      pPillAllLekEr->pSzezPntTmb = new unsigned [n_nev_klcs_tmb_mer] ;
      if ( pPillAllLekEr->pSzezPntTmb == NULL )
      {
        delete [] pPillAllLekEr->pNevKlcsTmb ;
        delete [] pPillAllLekEr->pNevHlyzTmb ;
        return -1 ;
      }

      /* Hany menetben tudjuk NEV_TMB_MER adagokban elhozni az eredmenyt ? */
      nElhSzama = pPillAllLekEr->uiSzezErTmbMeret / NEV_TMB_MER + 1 ;
      nElhIdx = 0 ;

      for ( i = 0 ; i < nElhSzama ; i++ )
      {
        /* Ez jelzi, hogy a neveket is el kell hozni */
        n_nev_klcs_tmb_mer = 0 ;

        EXEC SQL EXECUTE
          BEGIN

            /* Az adott nevek hanyadikak lettek, hany ponttal */
            szez_all.szez_eredm_elhoz( :nev_klcs_tmb, :n_nev_klcs_tmb_mer, :nev_hlyz_tmb, :szez_pnt_tmb) ;

          END ;
        END-EXEC ;

        /* Nem mindig teljes meretu tombot kell mozgatni */
        if ( pPillAllLekEr->uiSzezErTmbMeret - nElhIdx > NEV_TMB_MER )
        {
          n_nev_klcs_tmb_mer =  NEV_TMB_MER ;
        }
        else
        {
          n_nev_klcs_tmb_mer = pPillAllLekEr->uiSzezErTmbMeret - nElhIdx ;
        }

        memcpy( pPillAllLekEr->pNevKlcsTmb + nElhIdx, nev_klcs_tmb, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
        memcpy( pPillAllLekEr->pNevHlyzTmb + nElhIdx, nev_hlyz_tmb, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
        memcpy( pPillAllLekEr->pSzezPntTmb + nElhIdx, szez_pnt_tmb, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;

        nElhIdx += n_nev_klcs_tmb_mer ;
      }

/*      pPillAllLekEr->uiSzezErTmbMeret = nElhIdx ; folosleges l. fent */
    }
/*
for ( unsigned ui = 0 ; ui < pPillAllLekEr->uiSzezErTmbMeret ; ui++ )
{
  TRACE("\nui:%d nev_klcs_tmb:%d nev_hlyz_tmb:%d szez_pnt_tmb:%d",
        ui,
        pPillAllLekEr->pNevKlcsTmb[ui],
        pPillAllLekEr->pNevHlyzTmb[ui],
        pPillAllLekEr->pSzezPntTmb[ui]) ;
}
*/
  }

  /* Nev kulcsok szerint rendezve van az eredmeny a szez_all package-ben,                */
  /* ha a parameterkent atadott nev kulcs tomb rendezett, nem kell minden nevre az       */
  /* eredmenyeket elolrol atnezni, meg lehet jegyezni az utolsonak vett eredmeny indexet */

  if ( bMindElhoz == TRUE )
  {
    /* besz_eredm_elhoz fuggveny kimenoadatai merete */
    EXEC SQL EXECUTE
      BEGIN

        :n_ossz_er_tmb_mer := szez_all.n_max_eredm_idx ;

      END ;
    END-EXEC ;

    pPillAllLekEr->uiOsszErTmbMer = n_ossz_er_tmb_mer ;

    if ( n_ossz_er_tmb_mer > 0 )
    {
      /* A beszamitott vilagbajnoki eredmenyek */
      pPillAllLekEr->pNevEredmTmb  = new unsigned [n_ossz_er_tmb_mer] ;
      pPillAllLekEr->pPontTmb      = new unsigned [n_ossz_er_tmb_mer] ;
      pPillAllLekEr->pHelyezesTmb  = new unsigned [n_ossz_er_tmb_mer] ;
      pPillAllLekEr->pNvzlKulcsTmb = new unsigned [n_ossz_er_tmb_mer] ;
      pPillAllLekEr->pNdNevTmb     = new unsigned [n_ossz_er_tmb_mer] ;

      if ( pPillAllLekEr->pNevEredmTmb  == NULL ||
           pPillAllLekEr->pPontTmb      == NULL ||
           pPillAllLekEr->pHelyezesTmb  == NULL ||
           pPillAllLekEr->pNvzlKulcsTmb == NULL ||
           pPillAllLekEr->pNdNevTmb     == NULL )
      {
        delete [] pPillAllLekEr->pNevEredmTmb  ;
        delete [] pPillAllLekEr->pPontTmb      ;
        delete [] pPillAllLekEr->pHelyezesTmb  ;
        delete [] pPillAllLekEr->pNvzlKulcsTmb ;
        delete [] pPillAllLekEr->pNdNevTmb     ;

        pPillAllLekEr->uiOsszErTmbMer = 0 ;

        return -1 ;
      }

      nElhSzama = pPillAllLekEr->uiOsszErTmbMer / EREDM_TMB_MER + 1 ;
      nElhIdx = 0 ;

      for ( i = 0 ; i < nElhSzama ; i++ )
      {
        /* Nem mindig teljes meretu tombot kell mozgatni */
        if ( pPillAllLekEr->uiOsszErTmbMer - nElhIdx > EREDM_TMB_MER )
        {
          n_ossz_er_tmb_mer = EREDM_TMB_MER ;
        }
        else
        {
          n_ossz_er_tmb_mer = pPillAllLekEr->uiOsszErTmbMer - nElhIdx ;
        }

        EXEC SQL EXECUTE
          BEGIN

        /* Az osszes beszamitott eredmeny elhozasa         */
        szez_all.besz_eredm_elhoz( :nev_klcs_tmb,  0,
                                   :nev_eredm_tmb, :pont_tab,
                                   :helyezes_tab,  :nvzl_kulcs_tab,
                                   :nd_nev_tab,    :n_ki_besz_tab_mer) ;

          END ;
        END-EXEC ;

        memcpy( pPillAllLekEr->pNevEredmTmb + nElhIdx,  nev_eredm_tmb,  n_ossz_er_tmb_mer*sizeof(unsigned)) ;
        memcpy( pPillAllLekEr->pPontTmb + nElhIdx,      pont_tab,       n_ossz_er_tmb_mer*sizeof(unsigned)) ;
        memcpy( pPillAllLekEr->pHelyezesTmb + nElhIdx,  helyezes_tab,   n_ossz_er_tmb_mer*sizeof(unsigned)) ;
        memcpy( pPillAllLekEr->pNvzlKulcsTmb + nElhIdx, nvzl_kulcs_tab, n_ossz_er_tmb_mer*sizeof(unsigned)) ;
        memcpy( pPillAllLekEr->pNdNevTmb + nElhIdx,     nd_nev_tab,     n_ossz_er_tmb_mer*sizeof(unsigned)) ;

        nElhIdx += n_ossz_er_tmb_mer ;
      }
    } /* Csak ha van mit elhozni */
  }
  else
  {
    /* Nem lehet tudni, a kivalasztott nevekhez hany eredmeny tartozik ! */
    /* A szezon eredmenyek elhozasa kapcsan kiderult, hany nevhez van eredmeny */
    nLokNevTmbMeret = pPillAllLekEr->uiSzezErTmbMeret ;
    pLokNevKlcsTmb = new unsigned [nLokNevTmbMeret] ;
    if ( pLokNevKlcsTmb == NULL )
    {
      return -1 ;
    }

    memcpy( pLokNevKlcsTmb, pPillAllLekEr->pNevKlcsTmb, pPillAllLekEr->uiSzezErTmbMeret*sizeof(unsigned)) ;

    /* A kivalasztott nev kulcsok sorbarendezese, mivel az elhozott nev kulcsok   */
    /* is sorba vannak rendezve. Igy egyszeruen meg lehet a kimeno nev kulcs tomb */
    /* ismereteben, hogy a bemeno nev kulcs tombot mely kulcstol kell ismetelni.  */
    qsort( (void*)pLokNevKlcsTmb, nLokNevTmbMeret, sizeof(unsigned), KulcsOsszeh) ;

    nUtElhNevIdx  = 0 ;
    nBeszEredmMer = 0 ;

    if ( nLokNevTmbMeret - nUtElhNevIdx > NEV_TMB_MER )
    {
      memcpy( nev_klcs_tmb, pLokNevKlcsTmb, NEV_TMB_MER*sizeof(unsigned)) ;
      n_nev_klcs_tmb_mer = NEV_TMB_MER ;
/*      nUtElhNevIdx       = NEV_TMB_MER -1 ;*/
    }
    else
    {
      memcpy( nev_klcs_tmb, pLokNevKlcsTmb, nNevTmbMeret*sizeof(unsigned)) ;
      n_nev_klcs_tmb_mer = nLokNevTmbMeret - nBeszEredmMer ;
/*      nUtElhNevIdx       = n_nev_klcs_tmb_mer - 1 ;*/
    }

    /* Hogy belefusson a ciklusba */
    n_ki_besz_tab_mer = 1 ;
/*                                                \/ ??? */
    while ( n_ki_besz_tab_mer > 0 && nUtElhNevIdx < nNevTmbMeret )
    {
/*
for ( unsigned c = 0 ; c < n_nev_klcs_tmb_mer ; c++ )
{
TRACE( "\nidx:%d. nev_klcs_tmb:%d",
       c,
       nev_klcs_tmb[c]) ;
}
*/
      EXEC SQL EXECUTE
        BEGIN

          szez_all.besz_eredm_elhoz( :nev_klcs_tmb,  :n_nev_klcs_tmb_mer,
                                     :nev_eredm_tmb, :pont_tab,
                                     :helyezes_tab,  :nvzl_kulcs_tab,
                                     :nd_nev_tab,    :n_ki_besz_tab_mer) ;

        END ;
      END-EXEC ;
/*
TRACE( "\nbesz_eredm_elhoz--------------------------------\n") ;

for ( unsigned u = 0 ; u < n_ki_besz_tab_mer ; u++ )
{
TRACE( "\nidx:%d. nev:%d  pont:%d helyz:%d nvzl:%d nd:%d",
       u,
       nev_eredm_tmb[u],
       pont_tab[u],
       helyezes_tab[u],
       nvzl_kulcs_tab[u],
       nd_nev_tab[u]) ;
}
*/
      if ( n_ki_besz_tab_mer > 0 )
      {
        nBeszEredmMer = nBeszEredmMer + n_ki_besz_tab_mer ;

        /* Helyfoglalas az ujonnan elhozottakkal novelt eredmenytombnek */
        pINevEredmTmb  = new unsigned [nBeszEredmMer] ;
        pIPontTmb      = new unsigned [nBeszEredmMer] ;
        pIHelyezesTmb  = new unsigned [nBeszEredmMer] ;
        pINvzlKulcsTmb = new unsigned [nBeszEredmMer] ;
        pINdNevTmb     = new unsigned [nBeszEredmMer] ;

        if ( pINevEredmTmb  == NULL || pIPontTmb == NULL || pIHelyezesTmb  == NULL ||
             pINvzlKulcsTmb == NULL || pINdNevTmb == NULL )
        {
          delete [] pLokNevKlcsTmb ;

          delete [] pINevEredmTmb  ;
          delete [] pIPontTmb      ;
          delete [] pIHelyezesTmb  ;
          delete [] pINvzlKulcsTmb ;
          delete [] pINdNevTmb     ;

          return -1 ;
        }

        /* A regi eredmeny es az ujonnan elhozottak osszemasolasa */   
        i          = pPillAllLekEr->uiOsszErTmbMer  ;
        nHosszRegi = i*sizeof(unsigned) ; /*(nBeszEredmMer - n_ki_besz_tab_mer)*/
        nHosszUj   = n_ki_besz_tab_mer*sizeof(unsigned) ;

        memcpy( pINevEredmTmb,    pPillAllLekEr->pNevEredmTmb,  nHosszRegi) ;
        memcpy( pINevEredmTmb+i,  nev_eredm_tmb,                 nHosszUj) ;

        memcpy( pIPontTmb,        pPillAllLekEr->pPontTmb,      nHosszRegi) ;
        memcpy( pIPontTmb+i,      pont_tab,                     nHosszUj) ;

        memcpy( pIHelyezesTmb,    pPillAllLekEr->pHelyezesTmb,  nHosszRegi) ;
        memcpy( pIHelyezesTmb+i,  helyezes_tab,                 nHosszUj) ;

        memcpy( pINvzlKulcsTmb,   pPillAllLekEr->pNvzlKulcsTmb, nHosszRegi) ;
        memcpy( pINvzlKulcsTmb+i, nvzl_kulcs_tab,               nHosszUj) ;

        memcpy( pINdNevTmb,       pPillAllLekEr->pNdNevTmb,     nHosszRegi) ;
        memcpy( pINdNevTmb+i,     nd_nev_tab,                   nHosszUj) ;

        delete [] pPillAllLekEr->pNevEredmTmb  ;
        delete [] pPillAllLekEr->pPontTmb      ;
        delete [] pPillAllLekEr->pHelyezesTmb  ;
        delete [] pPillAllLekEr->pNvzlKulcsTmb ;
        delete [] pPillAllLekEr->pNdNevTmb     ;

        pPillAllLekEr->pNevEredmTmb  = pINevEredmTmb  ;
        pPillAllLekEr->pPontTmb      = pIPontTmb      ;
        pPillAllLekEr->pHelyezesTmb  = pIHelyezesTmb  ;
        pPillAllLekEr->pNvzlKulcsTmb = pINvzlKulcsTmb ;
        pPillAllLekEr->pNdNevTmb     = pINdNevTmb     ;

        /* A beszamitott eredmenyek szamanak beallitasa */
        pPillAllLekEr->uiOsszErTmbMer = nBeszEredmMer ;

        /* A nev_klcs_tmb eloremozgatasa ahhoz a nevhez, amelyhez az utolso */
        /* elhozott besz.er.tartozik Persze lehet az is, hogy meg az elso   */
        /* nevhez sem hozott el mindent akkor az elso marad az utolso       */
        /* A pLokNevKlcsTmb-rol itt feltetelezzuk, hogy novekvo sorrendben rendezett */
        /* Nem kell elolrol, ugyis csak innen adtam at \/ */
        while ( nUtElhNevIdx < nLokNevTmbMeret && *(pLokNevKlcsTmb+nUtElhNevIdx) != nev_eredm_tmb[n_ki_besz_tab_mer - 1] )
        {
          nUtElhNevIdx++ ;
        }

        if ( nLokNevTmbMeret > NEV_TMB_MER + nUtElhNevIdx )
        {
          memcpy( nev_klcs_tmb, pLokNevKlcsTmb+nUtElhNevIdx, NEV_TMB_MER*sizeof(unsigned)) ;
          n_nev_klcs_tmb_mer = NEV_TMB_MER ;
        }
        else
        {
          n_nev_klcs_tmb_mer = nLokNevTmbMeret - nUtElhNevIdx ;
          memcpy( nev_klcs_tmb, pLokNevKlcsTmb+nUtElhNevIdx, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
        }
      }
      else /* Ehhez a NEV_TMB_MER meretu nev kulcs reszhez nem volt eredmeny */
      {
        /* Ha ez(^) ugy esett meg, hogy a nev mar az utolso megadott volt, nincs */
        /* tobb elhozando eredmeny, ki kell szallni a ciklusbol                  */
        if ( nUtElhNevIdx == nLokNevTmbMeret - 1 )
        {
          break ;
        }

        if ( nLokNevTmbMeret - nUtElhNevIdx > NEV_TMB_MER )
        {
          memcpy( nev_klcs_tmb, pLokNevKlcsTmb+nUtElhNevIdx, NEV_TMB_MER*sizeof(unsigned)) ;
          n_nev_klcs_tmb_mer = NEV_TMB_MER ;
        }
        else
        {
          n_nev_klcs_tmb_mer = nLokNevTmbMeret - nUtElhNevIdx ;
          memcpy( nev_klcs_tmb, pLokNevKlcsTmb+nUtElhNevIdx, n_nev_klcs_tmb_mer*sizeof(unsigned)) ;
        }

        nUtElhNevIdx += n_nev_klcs_tmb_mer ;
      }
    }

    delete [] pLokNevKlcsTmb ;

/*    pPillAllLekEr->uiOsszErTmbMer = nUtElhNevIdx ; ??? */
  }

  /* ----------------------------------------------------------------------- */

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  return l_SQLCODE ;

sql_hiba :
/*
for ( unsigned ui = 0 ; ui < 18 ; ui++ )
{
  TRACE("\nui:%d nev_klcs_tmb:%d nev_hlyz_tmb:%d szez_pnt_tmb:%d", ui, nev_klcs_tmb[ui], nev_hlyz_tmb[ui], szez_pnt_tmb[ui]) ;
}
*/
  /* Tombok felszabaditasa ? */
  EXEC SQL WHENEVER SQLERROR CONTINUE ;

  SQL_SQLCAFeltolt() ;

  l_SQLCODE = sqlca.sqlcode ;

  return l_SQLCODE ;
} ;

int KulcsOsszeh( const void* pKulcs1, const void* pKulcs2)
{
  if ( *((const unsigned*)pKulcs1) < *((const unsigned*)pKulcs2) )
  {
    return -1 ;
  }

  if ( *((const unsigned*)pKulcs1) > *((const unsigned*)pKulcs2) )
  {
    return 1 ;
  }

  return 0 ;
}
/*
mind :
   SELECT n.rajtszam, n.versenyzo, n.nemzetiseg, n.csapat, n.motor

IDC_LEK1_FUTGY_RB2    :
          b.szezon_eve, b.nagydij_nev, b.helyezes, b.ora, b.perc, b.masodperc, b.ezrdmsdperc (, r/b.megjegyzes)
     FROM nevezesi_lista n,
          befuto b,
     WHERE
          b.szezon_eve > :n_szez_eve  AND
          n.kulcs      = b.nvzl_kulcs AND
          b.helyezes   = 1 AND

IDC_LEK1_EDZELS_RB3   :
          r.szezon_eve, r.nagydij_nev, r.helyezes, r.perc, r.masodperc, r.ezrdmsdperc (, r/b.megjegyzes)
     FROM nevezesi_lista n,
          rajtsorrend r,
     WHERE
          r.szezon_eve > :n_szez_eve  AND
          n.kulcs      = r.nvzl_kulcs AND
          b.helyezes   = 1 AND

IDC_LEK1_LEGGYKOR_RB4 :
          l.szezon_eve, l.nagydij_nev, l.perc, l.masodperc (l.korben, l.atl_sebesseg)
     FROM nevezesi_lista n,
          leggyorsabb_kor l
     WHERE
          l.szezon_eve > :n_szez_eve  AND
          n.kulcs      = l .nvzl_kulcs AND

ID_LEKERD_VERSENYZNV  :                         kapcsolat kell meg a nevezesi_lista es r/b/l tablak kozott
         n.versenyzo   = :n_nev_kulcs AND


ID_LEKERD_NEMZETISGNV :
         n.nemzetiseg  = :n_nev_kulcs AND

ID_LEKERD_CSAPAT      :
         n.csapat      = :n_nev_kulcs AND

ID_LEKERD_MOTORNV     :
         n.motor       = :n_nev_kulcs AND

ID_LEKERD_NAGYDJNV    :
  IDC_LEK1_FUTGY_RB2    :
         b.nagydij_nev = :n_nev_kulcs AND

  IDC_LEK1_EDZELS_RB3   :
         r.nagydij_nev = :n_nev_kulcs AND

  IDC_LEK1_LEGGYKOR_RB4 :
         l.nagydij_nev = :n_nev_kulcs AND

nincs ilyen :
ID_LEKERD_PALYANV       :

*/
/*
for ( uiIdx = 0 ; uiIdx < nCiklFelsHat ; uiIdx++ )
{
  TRACE("\nR:%d, V:%d, N:%d, C:%d, M:%d, S:%d, N:%d, H:%d, O:%d, P:%d, M:%d, E:%d",
         rs_bef_lek_rekord[uiIdx].n_rajtszam,
         rs_bef_lek_rekord[uiIdx].n_versenyzo,
         rs_bef_lek_rekord[uiIdx].n_nemzetiseg,
         rs_bef_lek_rekord[uiIdx].n_csapat,
         rs_bef_lek_rekord[uiIdx].n_motor,
         rs_bef_lek_rekord[uiIdx].n_szezon_eve,
         rs_bef_lek_rekord[uiIdx].n_nagydij_nev,
//         rs_bef_lek_rekord[uiIdx].uiHelyezes,
         rs_bef_lek_rekord[uiIdx].n_ora,
         rs_bef_lek_rekord[uiIdx].n_perc,
         rs_bef_lek_rekord[uiIdx].n_masodperc,
         rs_bef_lek_rekord[uiIdx].n_ezrdmsdperc
      ) ;
}

for ( uiIdx = 0 ; uiIdx < nCiklFelsHat ; uiIdx++ )
{
  TRACE("\nR:%d, V:%d, N:%d, C:%d, M:%d, S:%d, N:%d, O:%d, P:%d, M:%d, E:%d",
         rs_bef_lek_rekord[uiIdx].n_rajtszam,
         rs_bef_lek_rekord[uiIdx].n_versenyzo,
         rs_bef_lek_rekord[uiIdx].n_nemzetiseg,
         rs_bef_lek_rekord[uiIdx].n_csapat,
         rs_bef_lek_rekord[uiIdx].n_motor,
         rs_bef_lek_rekord[uiIdx].n_szezon_eve,
         rs_bef_lek_rekord[uiIdx].n_nagydij_nev,
         rs_bef_lek_rekord[uiIdx].n_ora,
         rs_bef_lek_rekord[uiIdx].n_perc,
         rs_bef_lek_rekord[uiIdx].n_masodperc,
         rs_bef_lek_rekord[uiIdx].n_ezrdmsdperc
      ) ;
}
*/